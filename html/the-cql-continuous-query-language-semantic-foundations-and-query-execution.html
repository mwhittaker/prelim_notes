<!DOCTYPE html>
<html>
<head>
  <title>Prelim Notes</title>
  <link href='../css/style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id=header>
    <a href="../">Prelim Notes</a>
  </div>
  <div id="container">
<h1 id="the-cql-continuous-query-language-semantic-foundations-and-query-execution">The CQL Continuous Query Language: Semantic Foundations and Query Execution</h1>
<ul>
<li><a href="https://mwhittaker.github.io/papers/html/arasu2006cql.html" class="uri">https://mwhittaker.github.io/papers/html/arasu2006cql.html</a></li>
<li>Overview
<ul>
<li>A database management system (DBMS) allows user to write ad-hoc queries against a static (or slowly changing) database. A data stream management system (DSMS) allows users to register stream queries which continuously run against streamed inputs.</li>
</ul></li>
<li>Streams and Relations
<ul>
<li>We assume an ordered time domain $\mathcal{T}$.</li>
<li>A <strong>stream</strong> $S$ is a multiset with entries of the form $(s, \tau)$ where $s$ is a tuple and $\tau \in \mathcal{T}$. We assume that there is a finite number of tuples per timestep.</li>
<li>A <strong>relation</strong> $R$ is a function from the time domain $\mathcal{T}$ to a multiset of tuples (i.e. to a standard relation). $R(\tau)$ is the relation at time $\tau$.</li>
</ul></li>
<li>Abstract Semantics
<ul>
<li>The abstract semantics is based on <strong>stream-to-relation</strong>, <strong>relation-to-relation</strong>, and <strong>relation-to-stream</strong> operators.</li>
</ul></li>
<li>Stream-to-relation
<ul>
<li><strong>Time-based windows</strong>: <code>S[Range T]</code> is a relation with all the tuples within the time range <code>T</code>.</li>
<li><strong>Tuple-based windows</strong>: <code>S[Rows n]</code> is a relation with the <code>n</code> most recent tuples; ties are broken arbitrarily.</li>
<li><strong>Partitioned windows:</strong> <code>S[Partition By A1, ..., Ak Rows n]</code> is a relation with the <code>n</code> most recent tuples for every group of <code>A1, ...,   Ak</code>.</li>
</ul></li>
<li>Relation-to-stream
<ul>
<li><code>Istream</code>$(R)$ at time $\tau$ contains $R(\tau) - R(\tau - 1)$. Used mostly with unbounded ranges.</li>
<li><code>Dstream</code>$(R)$ at time $\tau$ contains $R(\tau - 1) - R(\tau)$.</li>
<li><code>Rstream</code>$(R)$ at time $\tau$ contains $R(\tau)$. Used mostly with now ranges.</li>
<li>Istream and Dstream can be implemented using Rstream.</li>
<li>By default, unbounded ranges are added, and Istreams are added to monotonic queries.</li>
</ul></li>
<li>See paper for example queries.</li>
<li>Time Management
<ul>
<li>In order to process a query at time $\tau$, we have to know that there are no more inbound tuples with time $\leq \tau$. To do so, input sources use <strong>heartbeats</strong> (low watermark). A heartbeat at time $\tau$ indicates that no more inputs with time $\leq \tau$ will be sent. There are three mechanisms for heartbeats:</li>
<li>If timestamps are generated by a centralized DSMS, then calculating a low watermark is simple.</li>
<li>If input sources deliver tuples in increasing timestamp order, then we can collect heartbeats from the sources and use the minimum heartbeat as a low watermark.</li>
<li>If we have a global clock and bounded message delay, then we can infer the low watermark. For example, if it's 1:42 and the message delay is 1 minute, then we know that we have all messages from 1:41.</li>
</ul></li>
<li>Equivalences in CQL
<ul>
<li>All relation-to-relation query optimizations and materialized view optimizations can be leveraged.</li>
<li><strong>Window Reduction</strong>: <code>SELECT Istream(L) FROM S[Range Unbounded] WHERE C</code> is equivalent to <code>SELECT Rstream(L) FROM S[Now] WHERE C</code>.</li>
<li><strong>Filter-Window Commutativity</strong>: <code>(SELECT L FROM S WHERE C) [Range T]</code> is equivalent to <code>SELECT L FROM S[Range T] WHERE C</code>. Note the query is a simple SELECT-FROM-WHERE query.</li>
</ul></li>
<li>CQL Implementation in STREAM
<ul>
<li>Streams and relations are represented as a stream of triples $(s, \tau, \text{insert} | \text{delete})$ in nondecreasing timestamp order. Streams are represented as a sequence of insertions. Relations are represented as a sequence of insertions and deletions.</li>
<li>A query plan is a graph in which vertices are <strong>operators</strong> and edges are <strong>queues</strong> (in memory). Operators read streams and relations (in their unified format) from their input queues and output a stream or relation on their output queue.</li>
<li>Every operator has a corresponding <strong>synopsis</strong> (in memory) in which it can maintain its state. For example, a sliding window join may create a couple of hash tables.</li>
<li>Tuple are not copied when possible. Instead, they are stored in synopses, and tuple references are passed around.</li>
<li>Multiple queries can (and should) be combined into a single query plan.</li>
<li>A global scheduler decides how to evaluate the query plan graphs.</li>
<li>STREAM (a DSMS that implements CQL) has physical operators for all of the CQL operators and a couple of lower-level system operators.</li>
</ul></li>
<li>Questions
<ul>
<li>Q: Give an example stream query that has ambiguous semantics and explain how CQL makes the semantics clear.</li>
<li>A: ???</li>
<li>Q: What is the relationship between stream processing and materialized views?</li>
<li>A: The specification of a materialized view is a lot like a stream query. The materialized view is updated over time as the base tables change. Stream processing systems also use a lot of the same implementation strategies developed for materialized views.</li>
<li>Q: CQL includes both streams and relations. Can we remove relations and maintain the same expressiveness?</li>
<li>A: Yes. You can encode relations using streams. However, many concepts are more naturally expressed as time varying relations than as a stream of values.</li>
<li>Q: How can we implement Istream and Dstream as an Rstream?</li>
<li>A: ???</li>
<li>Q: Why is a SQL query plan a tree but a CQL query plan a graph?</li>
<li>A: ???</li>
<li>Q: How do you implement the stream-based relation-to-relation operators?</li>
<li>A: ???</li>
</ul></li>
</ul>
  </div>

  <script type="text/javascript" src="../js/mathjax_config.js"></script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</body>
</html>
